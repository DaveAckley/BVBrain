{57}  -*-  mode: text; fill-column: 50;  -*-
[0:

Fri Feb 16 14:11:49 2024 OK so we've finally
finally finnaly kind of arrived at ulam level and
we need some API to get serious about.
[1:

Fri Feb 16 14:15:23 2024 We'd done some fresh part
on that but I forgot to push the notes file so
it's not here right now and the link seems to be
down again grr. We just have the awful
autogenerated transcript. [2:

Fri Feb 16 14:21:31 2024 Ah link is back, tx e! So
here was the main angles from this past Monday:

    PROMPT: ORGANIC ROUTING IN ULAM

    QBody
    Net
    Grip
    Terminals
    Fresh signals map to particle creation / consumption

    Term
     String mName
     Bool mFresh
     Unsigned(2) mType; // unused, sensor, motor, reserved
     union {
      Unsigned(8) mUVal;
      Int(8) mSVal;
     }

    QBody
     Unsigned(8) getNumTerms() native; //< total in term physics
     String getTermName(Unsigned(8) index) native; //< across total physics
     Unsigned(8) getTermIndex(String name) native; //< "

     Unsigned getNumVals() native; //< in this site/tile
     Term getTerm(Unsigned idx) native;

[3:

Fri Feb 16 14:33:11 2024 So I guess what I'm
looking for most immediately is stuff related to
the native methods. We now have gotten a
BrainStemSupport.{h,tcc,cpp} successfully building
here in our BVBrain physics; we want to populate
it and Uq_10109211BVBrainStem10_native.tcc now.
[4:

Fri Feb 16 14:34:58 2024 I guess a first stop
would be to just get BrainStem.ulam to start
exposing some of the BrainStemSupport methods.

Like.. [5:

Fri Feb 16 14:38:59 2024 Well wait a sec; we do
need some more basic design first.

So, we're thinking BrainStemSupport will basically
be a statically allocated singleton, which
individual native methods call into but do not
own. And we're thinking it would go a little
something like this:

Bool update() native;
 - true iff a new sm packet has been seen by stem
   since last update() call. Idea is to call this
   once at beginning of stem-related event
   processing, and it calls BSS::readInputFile()
 - It will probably check for updating tags file
   and whatever as well? And, actually, responding
   to the input by updating the output.. basically
   all of this:

        tryLoadTags();
        if (readInputFile())
          tryRouting();
        writeOutputFile();
        ++_updates;

or is it

        tryLoadTags();
        if (readInputFile())
          writeOutputFile();

or is it
  
        tryLoadTags();
        return readInputFile();

plus like

     Void act() {
       writeOutputFile();
     }

or something?
[6:

Fri Feb 16 14:58:57 2024 Maybe it's like open()
and close()

Bool BVBrain.open() native ->
   tryLoadTags();
   return readInputFile();

Bool BVBrain.close() native ->
   writeOutputFile()
   return true; // Void?

:6]
:5]

:4]

:3]
:2]

:1]
:0]
[7:

Fri Feb 16 23:44:33 2024 So OK. It's clear still
in this early stage of development that we really
really really want a PyBulletTime <-> mfms link
to build all this stuff.

Of fogging course.

So how would that go? Let's review the flow:

HOST
PyBulletTime/src/WorldRunner.py
 - runs the simulation
 - contains a PacketSpine which
   - contains a SerLoop which opens /dev/ttyUSB0, and
   - sends and receives packets over the wire

TILE
T2-12/base/apps/sercon/t2serloopRunner.sh
 - starts ./t2serloop.py as needed, which
   - sends and receives packets over the wire
   - reads /mnt/T2TMP/output.dat and
   - writes /mnt/T2TMP/input.dat and
   - writes /mnt/T2TMP/tags.dat

TILE/"mfmt2"
T2-12/base/apps/sercon/BrainStem.cpp
 - reads /mnt/T2TMP/input.dat and
 - reads /mnt/T2TMP/tags.dat and
 - writes /mnt/T2TMP/output.dat 

[8:

Sat Feb 17 01:01:54 2024 So I think maybe a
reasonable simulation would be to like connect two
PTYs together and feed those devices to
WorldRunner.py and t2serloop.py, so everything
runs on the nominal 'host', and the API for mfmt2
and mfms is identical, going via /mnt/T2TMP.

Apparently 'socat' is a reasonably standard thing
for such tasks, which I've just installed here..

Let's learn a bit about socat for this task!

[9:

Sat Feb 17 01:20:52 2024 OK, well, modulo various
permissions issues, this

 # socat -d -d pty,b9600,raw,echo=0,link=/dev/ttyS90 pty,b9600,raw,echo=0,link=/dev/ttyS91

seems to create /dev/pts/22 and /dev/pts/23
and I can send stuff in both directions (using
echo and cat, for example).

So maybe we can make a script to set this stuff
up?

Actually let's first get some

TODO
[10: Sat Feb 17 11:54:41 2024
DONE:10] - WorldRunner.py takes optional serial device name
[13: Sat Feb 17 12:20:08 2024
DONE:13] - t2serloop.py takes optional serial device name
[14: Sat Feb 17 12:23:37 2024
DONE:14] - mfmsRunner.sh runs t2serloop.py /dev/pts/23
[11: Sat Feb 17 11:54:51 2024
DONE:11] - 'make debug' runs WorldRunner.py /dev/pts/22
[12: Sat Feb 17 11:55:01 2024 'RootWire.sh'
DONE:12] - DebugWire.sh (sets up /mnt/T2TMP) and runs socat
[24: Sun Feb 18 23:00:33 2024 so okay
DONE :24] - ulam native code does hardcoded BrainStem routing
 - come make more to-do

But first a break I think.

:9]
:8]

:7]       
[15:

Sat Feb 17 12:36:42 2024 OK that actually went in
pretty easily. We're already back to ulam & native
code..
[16:

Sat Feb 17 12:44:37 2024 OK,
BrainStemSupport::tryLoadFile and ::readInputFile
both succeeded, allowing BVBrainStem.open() to
succeed. Have we got any usable api at this level?

Well, :6: above says .close() should write the
output file - are we doing that?[17:

Sat Feb 17 12:55:47 2024 OK now we are. Have we
got ANYthing useful for ulam sensorimotor api?
[18:

Sat Feb 17 12:57:06 2024 I guess it's :2: above
from a fresh part. Maybe something related to

    QBody
     Unsigned(8) getNumTerms() native; //< total in term physics
     String getTermName(Unsigned(8) index) native; //< across total physics
     Unsigned(8) getTermIndex(String name) native; //< "

     Unsigned getNumVals() native; //< in this site/tile
     Term getTerm(Unsigned idx) native;

to proceed, here?[19:

Sat Feb 17 13:02:43 2024 OK we can't really want
String as the return type for getTermName, can we?
We don't think we can add Strings at runtime, and
we don't want to go down the road of wanting that.

:19]

:18]
:17]

:16]
:15]
[20:

Sun Feb 18 00:43:47 2024 OK, so, we've gotten this
far:

    20240218003906-269: 0AEPS [726FA197]MSG: print: Bool(3) 0x7 (true)
    20240218003906-270: 0AEPS [726FA197]MSG: print: "OPENED"
    20240218003906-271: 0AEPS [726FA197]MSG: Tag#0:[BVACT]
    20240218003906-272: 0AEPS [726FA197]MSG: Tag#1:[BVPITCH]
    20240218003906-273: 0AEPS [726FA197]MSG: Tag#2:[BVREQ]
    20240218003906-274: 0AEPS [726FA197]MSG: Tag#3:[BVROLL]
    20240218003906-275: 0AEPS [726FA197]MSG: Tag#4:[FLWHEEL]
    20240218003906-276: 0AEPS [726FA197]MSG: Tag#5:[MLR]
    20240218003906-277: 0AEPS [726FA197]MSG: Tag#6:[MRR]
    20240218003906-278: 0AEPS [726FA197]MSG: Tag#7:[SLFL]
    20240218003906-279: 0AEPS [726FA197]MSG: Tag#8:[SRFL]
    20240218003906-280: 0AEPS [726FA197]MSG: Tag#9:[SUPL]
    20240218003906-281: 0AEPS [726FA197]MSG: print: Bool(3) 0x7 (true)
    20240218003906-282: 0AEPS [726FA197]MSG: print: "CLOSED"

generated by an event running BVBrain.behave().
The code isn't pretty; the api ain't the nicest..
but the code runs.

So. How much more do we need before ulam routes a
signal?

Well how are we going to access term values? That
doesn't exist. Are we going to have a quark to
represent a term?[21:

Sun Feb 18 01:03:53 2024 Well what might that look
like?

quark SMTerm {
  Unsigned(2) mType; // none, sense, motor, both(?)
  ASCII mIndex;
  ASCII mValue;
}


:21]

:20]
[22:

Sun Feb 18 05:45:05 2024 Well, it's an utter hack,
but technically speaking we are now routing via
mfms and ulam events. With like:

    element BVBrain {
      BVBrainStem mBS;

      Void behave() {
        if (!mBS.open()) return;
        SMTerm tSLFL = mBS.readTermByName("SLFL");  // senses
        SMTerm tSRFL = mBS.readTermByName("SRFL");
        SMTerm tMLR = mBS.readTermByName("MLR");    // motors
        SMTerm tMRR = mBS.readTermByName("MRR");
        tMLR.setValue(tSRFL.getValue()); // good ole
        tMRR.setValue(tSLFL.getValue()); //  BV 2b
        mBS.writeTerm(tMLR);
        mBS.writeTerm(tMRR);
        mBS.close();
      }
    }

and merges/20240218-034359.mp4 is collecting the
results.. 

:22]
[23:

Sun Feb 18 11:02:54 2024 So, could we record mfms
captures somehow synchronized (at least by name)
to the PyBulletTime captures?

Could have a 'seconds spinner' sense that supplies
say the last 8 bits of the unix epoch, and have
BrainStemSupport.tcc read the rest of the time and
generate a filename and take a picture for that
name?

It would be running in the middle of an event; not
sure we've ever tried to render the grid at that
point; smells quite risky.

Perhaps we could set up a trigger asking mfms to
take a shot? Then it would do that between events?

Or maybe we just send the cadence? So 2 means
every even second, 5 means 0%5 seconds, etc. Then
the native code triggers a grab somehow that mfms
can do but mfmt2 can ignore..

:23]
[25:

Sun Feb 18 23:00:51 2024 OK, so we need more

TODO
[26: Mon Feb 19 01:22:39 2024 not offsets
DONE :26] - toml sets cadence (and perhaps process
   offsets?)
[27: Mon Feb 19 01:22:48 2024
DONE :27] - SecondsStep respects the cadence
[28: Mon Feb 19 01:59:08 2024 inband 'CADENCE' tag doh..
DONE :28] - t2serloop.py:indexConfig() respects the
   cadence, generating OoB tags perhaps?
[29: Mon Feb 19 02:11:47 2024 i think, anyway,
DONE :29] - make branch for existing 'V6' hacks and
   get rid of them for now
[30: Mon Feb 19 03:02:55 2024
DONE :30] - make some public MFM//gui method for requesting
   a render to a given path
[39: Wed Feb 21 23:40:48 2024
DONE :39] - have BrainStemSupport offer a cadence/phase
   tracking thing to detect first call 'on the
   beat' and request mfms render
[40: Wed Feb 21 23:40:59 2024 'newSenses()'
DONE :40] - BVBrainStem.open() calls actionsOnTheBeat() or
   whatever it's called
[41: in toml script, [config]/snapshotdir
DONE :41] - render mfms shots somewhere accessible
[42: in render15.pl
DONE :42] - make a script that makes links (?) to match
   a data/SIM-TAG, filling in transparency or
   something for misses (?)
[43: Wed Feb 21 23:42:05 2024
DONE!! :43] - watch a merge video of a BV2B run routed by
   mfms, with mfms screenshots synced
[46: Wed Feb 21 23:50:28 2024
DONE :46] - come make more to-do

:25]
[31:

Mon Feb 19 03:06:09 2024 OK how to we get to
AbstractGUIDriver from Uq.._native code?

..Add something to EventWindowRenderer?

Tired now. Later.[32:

Mon Feb 19 11:45:03 2024 Well for the life of me I
can't find any paths to the driver from src/core
or src/sim. Now I recall we tried hard to avoid
them but I didn't really think we had been so
successful..

Hmm what about in platform-specific?[33:

Mon Feb 19 11:53:38 2024 Well platform-specific is
pretty clean and essential and we're certainly not
going to fuck that up for this.
[34:

Mon Feb 19 11:54:44 2024 Do we really make a
static GetDriver * kind of thing? [35:

Mon Feb 19 12:00:16 2024 OK I found the
ever-so-slightly-suspiciously-named XXXDRIVER in
drivers/mfmc/src/main.cpp. It's declared at file
level but neither extern nor static. Can we see it
from native code?
[36:

Tue Feb 20 00:11:07 2024 Well, I tried to hack
stuff in around the XXXDRIVER but couldn't get
various multiple inheritance + dynamic_casting
abominations to work.

So I'm thinking of going back to src/core, and
making an 'official' rat hole extensions
mechanism. Something like

 virtual void * globalExtension(const char * name, void * arg) {
   return 0;
 }

which everybody can override with like

 virtual void * MINE::globalExtension(const char * name, void * arg) {
   MFM_API_ASSERT_NONNULL(name);
   if (!strcmp(name,"FOO")) return doFOO((Foo*) arg);
   return Super::globalExtension(name,arg);
 }

or however that goes in C++ (been a while gah). 

Except, except, except, that there's no top-level
object in src/core, right? That was kind of a
deliberate point wasn't it?

It could be like a singleton 'Hooks' thing that
people add their own hooks to?

struct GlobalHook {
  const char * m_name;
  virtual void * hookHandler(void * arg) = 0;
  struct GlobalHook m_next;
};

class GlobalHooks {
public:
  static GlobalHooks& getSingleton();
  void addHook(GlobalHook & hook) {
    MFM_API_ASSERT_NONNULL(hook.m_name);
    MFM_API_ASSERT_NULL(hook.m_next);
    hook.m_next = m_head;
    h_head = &hook;
  }
  void * runHook(const char * name, void * arg) {
    MFM_API_ASSERT_NONNULL(name);
    for (GlobalHook p = m_head; p; p = p->next) 
      if (!strcmp(name,p->m_name)) return p->hookHandler(arg);
    return 0;
  }
private:
  GlobalHooks() : m_head(0) { }
  GlobalHook * m_head;
};

:36]

:35]

:34]

:33]

:32]

:31]
[37:

Wed Feb 21 01:48:10 2024 Well, it looks like we
have mfms snapshots named by the cadence second,
getting stored in a toml-configured directory.
We're accummulating some now. We ought to be able
to come up with a modified script that will let us
find snapshot matches and merge them into the bv
movie somehow. Need to generate placeholder links
for missing matches, I guess. Probably generate
links for every frame, actually..[38:

Wed Feb 21 23:28:21 2024 aaaand we have
render15.pl now integrating time-matched mfms
screenshots into the rendering. Have a few samples
in 3148-20240305/sources/beevee/mfmsbrain/

Let's claim some to-do?

:38]

:37]
[44:

Wed Feb 21 23:42:20 2024 OK so we need more

TODO
 - checkpoint BVBrain, PyBulletTime, MFM, and co
[50: Thu Feb 22 11:42:16 2024 not super tested but
DONE :50] - extend BrainStemSupport somehow to have a
   newSenses(index) for per-sensor 'newness' not
   just per SM packet
[49: Thu Feb 22 11:41:54 2024 did some anyway
DONE :49] - think about routing designs for real
 - spike one or two exotic possibilities to stanch
   the dreaming
 - commit to a first routing design
 - come make more to-do

:44]
[45:

Wed Feb 21 23:48:29 2024 didn't realize we need
per-sensor newness until making up that to-do.
Let's just look at that first.[47:

Wed Feb 21 23:58:28 2024 Hmm but right now we've
tied the snapshots to the newSenses() call. Need
to move that to open or something instead, so the
first caller to open when there's new senses
requests the snapshot, but all the individual
senses remain new.

I'd changed BSS::newSenses() to anyNewSenses() but
maybe it should be something directly related to
snapshots..
[48:

Thu Feb 22 00:01:50 2024 Right now there's no
open/close abstraction in BrainStemSupport -
that's just laid on in the BrainStem native code -
but maybe there should be?

 open:
  - try load tags, and
  - try load config, and
  - readInputFile, and
  - requestSnapshot if inputfile is new, and
  - that's all?

:48]

:47]

:45]
[51:

Thu Feb 22 11:42:36 2024 So, we've imported the
Intender APIs from Ancestor211. It does seem to
help organize things. We're applying it to a
'Cloud' API that we are spiking for a non-rigid
hop-count-based 'routing ether'.

I'd like to emphasize cloud particles shifting and
spreading without necessarily always growing and
shrinking. Want to try to lean into 'gas
pressure'. Want to potentially have a gas cloud
expand and contract from the center, and spread by
jiggling, rather than growing at the periphery.

Let's try to demonstrate just that much. Some kind
of pressure estimator, plus some kind of desired
pressure gradient, plus jiggling to match local
pressure conditions.

So to do that, what kind of transition phases are
we looking for?

[52:

Thu Feb 22 11:56:05 2024 Well let's say first: How
do we estimate pressure and what do we want our
pressure gradient to be?

Perhaps we get non-'round' (ie diamond) gradients
because we'll integrate multiple hopcounts from
different anchors in a signal point.

So, pressure = (endopressure + exopressure) / count of available sites

endopressure = count of 'us'
exopressure = count of non-us non-empty

Perhaps it would be helpful to think it terms of
pressure 'bands'. Like minpressure/maxpressure
ranges for different hopcounts

aaand also do we even need much gradient? vs
constant pressure out to K hops and then 0 beyond
that?

aand are we also presuming something like 'stable
downs', where the center gets some idea how the
gradient is doing? so if we want constant pressure
out to 6 hops, and the guys at 3 hops are already
at minpressure..

so could we have the signals be 'position in
pressure band'? If downstream is hitting the
bottom of the band, that pulls upstream down, and
so forth, until a root sees underpressure and it
emits more cloud to adjust.

so let's just focus on endopressure first. We're
acting like we can examine ngbs pressures so it
needs to be represented somehow.

1 in 41 is ~2.5%

could 31 of 41 be the maximum possible density? ==
~76% ? Five bits directly interpreted? (Assuming
the ew is fully available.)

and a pressure band could be maybe 3 or 5
consecutive values in 0..31? Center + width

pressure band
  0..2 -> 0% -> ~5% 
  1..3   2.5% -> 7%

[53:

Thu Feb 22 16:41:15 2024 OK need some kind of
pressure rule immediately to code up. Like
max(0,4-chops/2) or something?

And what about going the other way? What about
having the density increase with distance?
Auto-membrane, like..
min(2,chops/2) up to chops 8 or something?
[54:

Thu Feb 22 23:18:42 2024 OK so it's easy to
imagine not moving too far away from your
minchops, but what about our minchops moving away
from us and creating a disconnection?

We could represent our minchops explicitly, so
they could tell we were counting on them. That
would give us a general tree. We could assemble
our children's SNs in a side array during observe.

But that also drives home that minchops should be
the closest-lowest up that we see, not just the
lowest, right? Otherwise we'll get pinned by
EW chop jumpers that can just barely see us?

 (1) It's an us
 (2) it's as close as any other us
 (3) it's minchops among those

:54]

:53]

:52]

:51]
[55:

Fri Feb 23 00:28:49 2024 OK I need something
simpler and/or using more existing code.

[56:

Fri Feb 23 04:01:17 2024 Well we made 'Gridder'
which does a land war style thing to resolve phase
inconsistencies in favor of the larger area
competitor. Works pretty well although long-lived
stalemates are possible, with the battle line
straightening and stagnating.

:56]

:55]
